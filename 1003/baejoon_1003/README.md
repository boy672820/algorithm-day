# DP(동적 계획법)을 이용한 풀이

문제에서 제시하는 피보나치 함수에서 0과 1이 몇 번 호출되는지 알아내는 문제이다.

```
int fibonacci(int n) {
    if (n == 0) {
        printf("0");
        return 0;
    } else if (n == 1) {
        printf("1");
        return 1;
    } else {
        return fibonacci(n‐1) + fibonacci(n‐2);
    }
}
```

문제를 유심히보면 메모리와 용량제한이 눈에 띈다. 위 코드와 같이 그냥 재귀 함수를 실행하면 시간 제한이 걸린다.(시간 복잡도 `O(n^2)`)

따라서 동적 계획법을 이용하여 풀이한다.

> *동적 계획법이란, 큰 문제를 작은 문제로 나누어 풀이한다. 분할 정복과 차이는 같은 문제를 다시 풀이하지 않는 것이다. 즉, 큰 작은 문제가 반복되는 것을 이용해 풀어나가는 방법이다.

## 메모이제이션(Memoization)

피보나치 함수를 보면 트리 구조로 값이 이어나간다. 여기서 이미 구한 값은 저장하여 다시 연산할 필요 없게 만들어야 한다.

예를 들어, f(n)의 경우 n=5는 아래와 같다.

- f(5) = f(4) - f(3)
- f(4) = f(3) - f(2)
- f(3) = f(2) - f(1)
- f(2) = f(1) - f(0)

2부터 n-1 까지의 값은 공통된 연산을 수행한다.

1과 0이 도출된 값 n에 대하여 배열에 저장해두면(메모이제이션) 나중에 저장된 값을 호출하여 연산하면 된다.