# 문제: Lockfile을 만들어보자

김토스는 패키지 매니저라는 게 존재하는지 모르고 있었습니다. 똑똑한 김토스는, 설치 당시의 버전을 명시해주는 것이 얼마나 중요한지 깨달았는데요. 이를 위해, 설치 당시의 버전들을 명시하는 lockFile을 생성하는 함수를 제작하려고 합니다. 김토스를 도와 lockFile을 생성하는 solution 함수를 만들어 주세요.

## 문제 정의

- packageJson이 주어졌을 때, 해당 패키지의 의존성 및 각 의존성들의 의존성들을 재귀적으로 탐색하여 설치되어야 할 정확한 패키지의 "이름@버전" 배열을 반환해주세요. 중복은 제거해야 하며 순서는 상관없습니다.
- 탐색 방식과 순서에 따라서 설치되어야 할 패키지 버전이 바뀌면 안되며 한 패키지는 두가지 이상의 버전으로 설치될 수 있습니다. 이 알고리즘에 대해서는 하단 결정적인 의존성 resolve 알고리즘을 자세히 읽어주세요.

## 제약사항

- packageJson 오브젝트와 fetchVersions, fetchPackageJson 함수를 입력으로 받습니다.
- fetchVersions 함수는 패키지 이름을 입력 받아서 버전정보 배열을 반환합니다.

```javascript
const versions = await fetchVersions('foo');

//    ^^^^^^^^
// ["0.0.3", "1.0.0", "1.0.1", "1.1.0", "1.2.0"]
```

- fetchPackageJson은 함수는 패키지 이름과 버전을 입력 받아서 packageJson 객체를 반환합니다.

```javascript
const packageJson = await fetchPackageJson('foo', '1.0.0');

//    ^^^^^^^^
// {
//   "name": "foo",
//   "version": "1.0.0",
//   "dependencies": {
//     "bar": "^2.0.0",
//     "baz": "^1.0.0"
//   }
// }
```

- packageJson에는 name, version, dependencies 필드가 있습니다. devDependencies는 없다고 가정합니다.

```json
{
  "name": "my-package",
  "version": "1.0.0",
  "dependencies": {
    "foo": "^1.0.0",
    "bar": "~1.3.0",
    "baz": "0.0.1",
    "qux": "*"
  }
}
```

- dependencies는 패키지이름과 버전 범위의 레코드로 되어있습니다.
- packageJson의 version 필드에는 정확한 시맨틱 버전 정보가 선언되어 있으며 dependencies에 선언되어있는 버전은 시맨틱 버저닝의 범위를 표현하고 있습니다.
- 시맨틱 버저닝으로 표현된 버전 문자열에는 .으로 분리된 세 묶음의 숫자가 존재하며 각각을 major, minor, patch라고 합니다.
- major.minor.patch의 형태이며 예를 들어 1.0.0의 경우 major는 1, minor는 0, 그리고 patch는 0이 됩니다.
- 모든 버전은 세 묶음의 숫자로 이루어져 있습니다. 즉 ^1 같은 표현은 존재하지 않습니다. 대신 ^1.0.0으로 표현되어 있습니다.
- 시맨틱 버저닝의 범위 표현법에는 네가지 종류가 존재하며 각각이 뜻하는 의미는 다음과 같습니다.
- ^1.0.0: major가 동일해야 하며, minor와 patch는 가능한 가장 최신 버전을 사용해야 합니다.
- ~1.3.0: major와 minor가 동일해야 하며, patch는 가능한 가장 최신 버전을 사용해야 합니다.
- 0.0.1: 정확히 0.0.1 버전만 사용해야 합니다.
- \*: 모든 버전을 사용할 수 있으며 그중에서 가장 최신 버전을 사용해야 합니다.

## 결정적인 의존성 resolve 알고리즘

foo 패키지에는 ['1.0.0', '1.1.0'] 버전이 존재하고 bar 패키지에는 ['0.1.0', '0.2.0'] 버전이 존재한다고 가정합니다. foo@1.1.0은 bar@\*를 의존하고 있으며 bar에는 의존성이 없습니다. 만약 foo@^1.0.0과 bar@0.1.0을 설치해야 한다고 했을 때, 의존성을 순회하는 두 가지 방식이 존재합니다.

### 너비 우선 탐색의 경우

- foo@^1.0.0 범위의 가장 최신 버전인 foo@1.1.0이 설치됩니다.
- bar@0.1.0은 해당 버전 그대로 bar@0.1.0이 설치됩니다.
- foo@1.1.0은 앞서 말한대로 bar@*를 의존하고 있으며 bar@*에 해당하는 범위중 가장 최신인 bar@0.2.0 버전이 설치됩니다.
- 따라서 프로젝트에는 ['foo@1.1.0', 'bar@0.1.0', 'bar@0.2.0']이 설치됩니다.

### 깊이 우선 탐색의 경우

- foo@^1.0.0 범위의 가장 최신 버전인 foo@1.1.0이 설치됩니다.
- foo@1.1.0은 앞서 말한대로 bar@*를 의존하고 있으며 bar@*에 해당하는 범위중 가장 최신인 bar@0.2.0 버전이 설치됩니다.
- bar@0.1.0은 해당 버전 그대로 bar@0.1.0이 설치됩니다.
- 따라서 프로젝트에는 ['foo@1.1.0', 'bar@0.1.0', 'bar@0.2.0']이 설치됩니다.

> [!NOTE]
>
> 이 때 주의 깊게 봐야 할 점은 이미 설치되어야 할 버전 정보들이 추후 의존성을 탐색하는 과정에서 바뀌지 않는다는 것입니다. 너비 우선 탐색의 경우 bar@0.1.0이 이미 설치된 상태에서 bar@* 범위의 의존성을 설치하고 있습니다. 이 때 bar@0.1.0은 bar@*에 포함되기 때문에 설치를 건너뛸 수 있다고 생각할 수 있는데, 그렇게 하면 안 됩니다. bar@0.2.0이 더 최신이므로 해당 버전을 설치해야 합니다. 이 알고리즘은 중복 패키지를 최소화하는 게 목적이 아니기 때문입니다.

## 입출력 형태

**입력 값:**

```javascript
const packageJson = {
  name: 'my-package',
  version: '1.0.0',
  dependencies: {
    foo: '^1.0.0'
  }
};

async function fetchVersions(packageName) { ... }

async function fetchPackageJson(packageName, version) { ... }

solution(packageJson, fetchVersions, fetchPackageJson);
```

**출력값 예시:**

```json
[
  "bar@1.3.2",
  "baz@10.1.0",
  "baz@11.0.20",
  "corge@17.1.4",
  "foo@1.2.1",
  "qux@3.1.3",
  "thud@4.50.1"
]
```
